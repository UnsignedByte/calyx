; -----------------------------------------------------------------------------
; DATATYPES
; -----------------------------------------------------------------------------

; Cell
(datatype _Cell)
(function Cell (String) _Cell)

; Set[Cell]
(sort CellSetBase (Set _Cell))
(sort _CellSet)
(function CellSet (CellSetBase) _CellSet)

; Group
(datatype _Group)
; TODO(cgyurgyik): Add static groups to guarantee the "static" attribute.
; TODO(cgyurgyik): Add combinational groups.
(function Group (String _CellSet) _Group)

; Attributes
(sort AttributeMap (Map String i64))
(datatype _Attributes)
(function Attributes (AttributeMap) _Attributes)

; List
(datatype Control)
(datatype List)
(function Cons (Control List) List)
(function Nil () List)

; Control
(function Enable (_Group _Attributes) Control)
(function Seq (_Attributes List) Control)
(function Par (_Attributes List) Control)

; Set[Control]
(sort ControlSetBase (Set Control))
(sort _ControlSet)
(function ControlSet (ControlSetBase) _ControlSet)

(ruleset analysis)
(ruleset control)
(ruleset list)

(function c-union (_ControlSet _ControlSet) _ControlSet)
(rule
    (
        (= a (ControlSet x))
        (= b (ControlSet y))
    )
    (
        (set (c-union a b) (ControlSet (set-union x y)))
    )
    :ruleset analysis
)

; (function c-length (_ControlSet) i64)
; (rule
;     (
;         (= C (ControlSet c))
;     )
;     (
;         (set (c-length C) (set-length c))
;     )
;     :ruleset analysis
; )

; -----------------------------------------------------------------------------
; LISTS
; -----------------------------------------------------------------------------

(function car (List) Control)
(rewrite
    (car (Cons x xs))
    x
)

(function cdr (List) List)
(rewrite
    (cdr (Cons x xs))
    xs
)
(rewrite
    (cdr (Nil))
    (Nil)
)

(function list-length (List) i64)

(set (list-length (Nil)) 0)

(rule
    ((Cons x xs)
        (= xs-length (list-length xs)))
    ((set (list-length (Cons x xs)) (+ xs-length 1)))
)

(function list-concat (List List) List)
(rewrite
    (list-concat (Cons x xs) (Nil))
    (Cons x xs)
    :ruleset list
)
(rewrite
    (list-concat (Nil) (Cons x xs))
    (Cons x xs)
    :ruleset list
)

(rewrite
    (list-concat (Cons x (Nil)) (Cons y ys))
    (Cons x (Cons y ys))
    :ruleset list
)

(rewrite
    (list-concat (Cons x xs) ys)
    (Cons x (list-concat xs ys))
)


(function list-reverse (List) List)
(rewrite
    (list-reverse (Nil))
    (Nil)
    :ruleset list
)
(rewrite
    (list-reverse (Cons x xs))
    (list-concat (list-reverse xs) (Cons x (Nil)))
    :ruleset list
)

(function _sliceB (List i64) List :unextractable) ; [begin, N)
(rewrite
    (_sliceB (Cons x xs) 0)
    (Cons x xs)
    :ruleset list
)
(rewrite
    (_sliceB (Cons x xs) begin)
    (_sliceB xs (- begin 1))
    :when ((> begin 0))
    :ruleset list
)

(function _sliceE (List i64) List :unextractable) ; [0, end)
(rewrite
    (_sliceE (Cons x xs) 0)
    (Nil)
    :ruleset list
)
(rewrite
    (_sliceE (Cons x xs) end)
    (Cons x (_sliceE xs (- end 1)))
    :when ((> end 0) (< end (list-length (Cons x xs))))
    :ruleset list
)
(rewrite
    (_sliceE (Cons x xs) end)
    (Cons x xs)
    :when ((= end (list-length (Cons x xs))))
    :ruleset list
)

(function list-slice (List i64 i64) List) ; [begin, end)
(rewrite
    (list-slice (Cons x xs) begin end)
    (_sliceE (_sliceB (Cons x xs) begin) (- end begin))
    :when ((>= end begin))
    :ruleset list
)

(rewrite
    (list-length (list-slice xs a b))
    (- b a)
    :when ((>= b a))
    :ruleset list
)

; (list-find x xs) 
; Returns the sub-list with x as the head, or nil if x is not found in xs.
(function list-find (Control List) List)
(rewrite
    (list-find y (Cons x xs))
    (Cons x xs)
    :when ((= x y))
    :ruleset list
)
(rewrite
    (list-find y (Cons x xs))
    (list-find y xs)
    :when ((!= x y))
    :ruleset list
)
(rewrite
    (list-find y (Nil))
    (Nil)
    :ruleset list
)

; -----------------------------------------------------------------------------
; CONSTANTS
; -----------------------------------------------------------------------------

(let FAN-OUT 2)
(let PAR-TO-SEQ 1000)
(let SPLIT-SEQ 8)

; -----------------------------------------------------------------------------
; ANALYSIS
; -----------------------------------------------------------------------------

; TODO(cgyurgyik): also need to account for memory-ordering.
(function exclusive (Control Control) bool :unextractable)

(rule
    (
        (= A (Enable (Group n1 (CellSet s1)) a1))
        (= B (Enable (Group n2 (CellSet s2)) a2))
        (> (set-length (set-intersect s1 s2)) 0)
    )
    (
        (set (exclusive A B) false)
    )
    :ruleset analysis
)

(rule
    (
        (= A (Enable (Group n1 (CellSet s1)) (Attributes m1)))
        (= B (Enable (Group n2 (CellSet s2)) (Attributes m2)))
        (= (set-length (set-intersect s1 s2)) 0)
    )
    (
        (set (exclusive A B) true)
    )
    :ruleset analysis
)

; Returns whether Control is exclusive with all values in List.
(function exclusive-with-all (Control List) bool)
(rule
    (
        (= E (Enable g a))
    )
    (
        (set (exclusive-with-all (Enable g a) (Nil)) true)
    )
    :ruleset analysis
)

(rule
    (
        (= E (Enable g a))
        (= _ (Cons x xs))
        (= result (exclusive E x))
        (= xs-exclusive (exclusive-with-all E xs))

    )
    (
        (set (exclusive-with-all E (Cons x xs)) (and result xs-exclusive))
    )
    :ruleset analysis
)

(rule
    (
        (= E (Enable g a))
        (= _ (Cons (Seq a ys) xs))
        (= ys-exclusive (exclusive-with-all E ys))
        (= xs-exclusive (exclusive-with-all E xs))
    )
    (
        (set (exclusive-with-all E (Cons (Seq a ys) xs)) (and ys-exclusive xs-exclusive))
    )
    :ruleset analysis
)

(rewrite
    (exclusive-with-all (Enable g _) (Cons (Par a ys) xs))
    (and (exclusive-with-all (Enable g _) ys) (exclusive-with-all (Enable g _) xs))
    :ruleset analysis
)

; Returns the set of non-exclusive control constructs.
; If the list contains a seq or par and its children are non-exclusive
; with x, then the entire seq/par is appended.
; (function nonexclusive-set (Control List) _ControlSet)
; (rule
;     (
;         (= E (Enable g a))
;     )
;     (
;         (set (nonexclusive-set E (Nil)) (ControlSet (set-empty)))
;     )
;     :ruleset analysis
; )

; (rule
;     (
;         (= E (Enable g a))
;         (= L (Cons x xs))
;         (not (exclusive E x))
;     )
;     (
;         (set (nonexclusive-set E L) (c-union (ControlSet (set-of x)) (nonexclusive-set E xs)))
;     )
;     :ruleset analysis
; )
; (rule
;     (
;         (= E (Enable g a))
;         (= L (Cons x xs))
;         (exclusive E x)
;     )
;     (
;         (set (nonexclusive-set E L) (nonexclusive-set E xs))
;     )
;     :ruleset analysis
; )

; (rewrite
;     (nonexclusive-set (Enable g _) (Cons (Seq a ys) xs))
;     (c-union (ControlSet (set-of (Seq a ys))) (nonexclusive-set (Enable g _) xs))
;     :when (
;         (not (exclusive-with-all (Enable g _) ys))
;     )
;     :ruleset analysis
; )

; (rewrite
;     (nonexclusive-set (Enable g _) (Cons (Seq a ys) xs))
;     (nonexclusive-set (Enable g _) xs)
;     :when (
;         (exclusive-with-all (Enable g _) ys)
;     )
;     :ruleset analysis
; )

; (rewrite
;     (nonexclusive-set (Enable g _) (Cons (Par a ys) xs))
;     (c-union (ControlSet (set-of (Par a ys))) (nonexclusive-set (Enable g _) xs))
;     :when (
;         (not (exclusive-with-all (Enable g _) ys))
;     )
;     :ruleset analysis
; )

; (rewrite
;     (nonexclusive-set (Enable g _) (Cons (Par a ys) xs))
;     (nonexclusive-set (Enable g _) xs)
;     :when (
;         (exclusive-with-all (Enable g _) ys)
;     )
;     :ruleset analysis
; )

; -----------------------------------------------------------------------------
; CONTROL
; -----------------------------------------------------------------------------

; seq { seq { ... } } => seq { ... }
(rewrite
    (Seq (Attributes a1) (Cons (Seq (Attributes a2) xs) (Nil)))
    (Seq (Attributes a2) xs)
    :when ((map-not-contains a1 "new_fsm") (map-not-contains a2 "new_fsm"))
    :ruleset control
)

; par { par { ... } } => par { ... }
(rewrite
    (Par (Attributes a1) (Cons (Par (Attributes a2) xs) (Nil)))
    (Par (Attributes a2) xs)
    :when ((map-not-contains a1 "new_fsm") (map-not-contains a2 "new_fsm"))
    :ruleset control
)

; par { A; B; C; D; } => par { par { A; B; } par { C; D; } }
(rewrite
    (Par (Attributes m) xs)
    (Par (Attributes m)
        (Cons (Par (Attributes (map-empty)) (list-slice xs 0 (/ (list-length xs) 2)))
            (Cons (Par (Attributes (map-empty)) (list-slice xs (/ (list-length xs) 2) (list-length xs)))
                (Nil))
        )
    )
    :when ((>= (list-length xs) FAN-OUT) (map-not-contains m "new_fsm") (map-not-contains m "static"))
    :ruleset control
)

; par { @promotable(1000) A; @promotable(1) B; } =>
; seq { @promotable(1000) A; @promotable(1) B; }
(rewrite
    (Par attr (Cons (Enable g1 (Attributes m1)) (Cons (Enable g2 (Attributes m2)) (Nil))))
    (Seq attr (Cons (Enable g1 (Attributes m1)) (Cons (Enable g2 (Attributes m2)) (Nil))))
    :when (
        (map-contains m1 "promotable")
        (map-contains m2 "promotable")
        (>= (- (map-get m1 "promotable") (map-get m2 "promotable")) PAR-TO-SEQ)
    )
    :ruleset control
)
(rewrite
    (Par attr (Cons (Enable g1 (Attributes m1)) (Cons (Enable g2 (Attributes m2)) (Nil))))
    (Seq attr (Cons (Enable g1 (Attributes m1)) (Cons (Enable g2 (Attributes m2)) (Nil))))
    :when (
        (map-contains m1 "promotable")
        (map-contains m2 "promotable")
        (>= (- (map-get m2 "promotable") (map-get m1 "promotable")) PAR-TO-SEQ)
    )
    :ruleset control
)


; seq { A; B; } => par { A; B; }
; (rewrite
;     (Seq attr (Cons A (Cons B (Nil))))
;     (Par attr (Cons A (Cons B (Nil))))
;     :when ((= (exclusive A B) true))
;     :ruleset control
; )



;  seq { A0; A1; ...; An; } =>
;  seq {
;    @new_fsm seq {A0; ...; A(n/2); }
;    @new_fsm seq {A(n/2); ...; An; }
;  }
(rule
    (
        (= S (Seq (Attributes attr) (Cons y ys)))
        (map-not-contains attr "new-fsm")
        (>= (list-length (Cons y ys)) SPLIT-SEQ)
    )
    (
        (let xs (Cons y ys))
        (let middle (/ (list-length xs) 2))
        (let s1 (Seq (Attributes (map-insert attr "new_fsm" 1)) (list-slice xs 0 middle)))
        (let s2 (Seq (Attributes (map-insert attr "new_fsm" 1)) (list-slice xs middle (list-length xs))))
        (union
            (Seq (Attributes attr) (Cons y ys))
            (Seq (Attributes attr) (Cons s1 (Cons s2 (Nil))))
        )
    )
    :ruleset control
)

(function max-latency (List) i64 :merge (min old new))
(set (max-latency (Nil)) 0)

(rule ; (max-latency Enable)
    (
        (= E (Cons (Enable _ (Attributes m)) xs))
        (= incumbent (max-latency xs))
        (map-contains m "promotable")
        (= current (map-get m "promotable"))
    )
    (
        (set (max-latency E) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency @static(N) Seq)
    (
        (= E (Cons (Seq (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-contains m "static")
        (= current (map-get m "static"))
    )
    (
        (set (max-latency (Cons (Seq (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency Seq) - No "static" attribute; go through children.
    (
        (= E (Cons (Seq (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-not-contains m "static")
        (= current (max-latency ys))
    )
    (
        (set (max-latency (Cons (Seq (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency @static(N) Par)
    (
        (= E (Cons (Par (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-contains m "static")
        (= current (map-get m "static"))
    )
    (
        (set (max-latency (Cons (Par (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency Par) - No "static" attribute; go through children.
    (
        (= E (Cons (Par (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-not-contains m "static")
        (= current (max-latency ys))
    )
    (
        (set (max-latency (Cons (Par (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

; max latency over the list if the control is in the set.
; (function max-latency-with-set (_ControlSet List) i64)
; (rule
;     (
;         (= CS (ControlSet cs))
;     )
;     (
;         (set (max-latency-with-set CS (Nil)) 0)
;     )
;     :ruleset analysis
; )

; (rule
;     (
;         (= CS (ControlSet cs))
;         (= x (Enable g (Attributes a)))
;         (= L (Cons x xs))
;         (set-contains cs x)
;         (map-contains a "promotable")
;         (= latencies (max-latency-with-set CS xs))
;     )
;     (
;         (let latency (map-get a "promotable"))
;         (set (max-latency-with-set CS L) (max latency latencies))
;     )
;     :ruleset analysis
; )

; (rule
;     (
;         (= CS (ControlSet cs))
;         (= x (Par (Attributes a) ys))
;         (= L (Cons x xs))
;         (set-contains cs x)
;         (map-contains a "static")
;     )
;     (
;         (let latency (map-get a "static"))
;         (set (max-latency-with-set CS L) (max latency (max-latency-with-set CS xs)))
;     )
;     :ruleset analysis
; )

; (rule
;     (
;         (= CS (ControlSet cs))
;         (= x (Seq (Attributes a) ys))
;         (= L (Cons x xs))
;         (set-contains cs x)
;         (map-contains a "static")
;     )
;     (
;         (let latency (map-get a "static"))
;         (set (max-latency-with-set CS L) (max latency (max-latency-with-set CS xs)))
;     )
;     :ruleset analysis
; )

(function sum-latency (List) i64 :merge (min old new))
(set (sum-latency (Nil)) 0)

(rule ; (sum-latency Enable)
    (
        (= ys (Cons (Enable _ (Attributes m)) xs))
        (= sum (sum-latency xs))
        (map-contains m "promotable")
        (= latency (map-get m "promotable"))
    )
    (
        (set (sum-latency ys) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency @static(N) Seq)
    (
        (= xss (Cons (Seq (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-contains m "static")
        (= latency (map-get m "static"))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency Seq) - No "static" attribute; Go through children.
    (
        (= xss (Cons (Seq (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-not-contains m "static")
        (= latency (sum-latency ys))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency @static(N) Par)
    (
        (= xss (Cons (Par (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-contains m "static")
        (= latency (map-get m "static"))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency Par)
    (
        (= xss (Cons (Par (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-not-contains m "static")
        (= latency (max-latency ys))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

; TODO(cgyurgyik): 
; @static(22) seq { A (1); B (10); C (1); D (10); }
;       A -> C, D
;       B -> C
; @static(11) par {
;  A;
;  B;
;  static seq {del_10; C; }
;  static seq {del_1;  D; }
; }

; seq { A; B; C; D; } => seq { par { A; } B; C; D; }
(rule
    (
        (= x (Enable g (Attributes m-e)))
        (= S (Seq attr (Cons x xs)))
        (> (list-length xs) 0) ; We only want to do this if we can eventually compact another group.
        (map-contains m-e "promotable")
    )
    (
        (let latency (map-get m-e "promotable"))
        (let p (Par (Attributes (map-insert (map-empty) "static" latency)) (Cons x (Nil))))
        (set (Seq attr (Cons x xs)) (Seq attr (Cons p xs)))

    )
    :ruleset control
)

; Case 1: A and B are exclusive. 
; seq { par { A; } B; C; D; } => seq { par { A; B; } C; D; }
(rule
    (
        (= x (Enable g (Attributes m-e)))
        (map-contains m-e "promotable")
        (= compaction (Par (Attributes a2) ys))
        (= S (Seq (Attributes a1) (Cons compaction (Cons x xs))))
        (exclusive-with-all x ys)
    )
    (
        (Cons x ys) ; Demand transformation for max-latency.
    )
    :ruleset control
)

(rule
    (
        (= x (Enable g (Attributes m-e)))
        (map-contains m-e "promotable")
        (= compaction (Par (Attributes a2) ys))
        (= S (Seq (Attributes a1) (Cons compaction (Cons x xs))))
        (exclusive-with-all x ys)
        (= l1 (max-latency (Cons x ys)))
        (= l2 (sum-latency xs))

    )
    (
        (let l3 (+ l1 l2))
        (let p-attr (Attributes (map-insert a2 "static" l1)))
        (let s-attr (Attributes (map-insert a1 "static" l3)))
        (union
            (Seq (Attributes a1) (Cons compaction (Cons x xs)))
            (Seq s-attr (Cons (Par p-attr (Cons x ys)) xs))
        )
    )
    :ruleset control
)


; Case 2: A and B are not exclusive. 
; seq { par { A; } B; C; D; } => seq { par { A; seq { _delay; B; } } C; D; }
; (rule
;     (
;         (= x (Enable g (Attributes m-e)))
;         (map-contains m-e "promotable")
;         (= compaction (Par (Attributes p-e) ys))
;         (map-contains p-e "static")
;         (= S (Seq (Attributes s-e) (Cons compaction (Cons x xs))))
;         (not (exclusive-with-all x ys))

;         (= CS (nonexclusive-set x ys))
;     )
;     (
;         (max-latency-with-set CS ys) ; demand
;     )
;     :ruleset control
; )

; (rule
;     (
;         (= x (Enable g (Attributes m-e)))
;         (map-contains m-e "promotable")
;         (= compaction (Par (Attributes p-e) ys))
;         (map-contains p-e "static")
;         (= S (Seq (Attributes s-e) (Cons compaction (Cons x xs))))
;         (not (exclusive-with-all x ys))

;         ; Need to recalculate latencies for the inner 
;         ; compaction as well as the outer seq.
;         (= CS (nonexclusive-set x ys))
;         (= L (max-latency-with-set CS ys))
;         (= l0 (+ L (map-get m-e "promotable")))
;         (= l1 (max l0 (max-latency ys)))
;         (= l2 (sum-latency xs))
;     )
;     (
;         ; group _delayL { ... }
;         (let delay-g (Group "_delay" (CellSet (set-empty))))
;         ; _delayL
;         (let delay (Enable delay-g (Attributes (map-insert (map-empty) "promotable" L))))
;         ; seq { _delayL; B; }
;         (let new-S (Seq
;                 (Attributes (map-insert (map-empty) "static" l0))
;                 (Cons delay (Cons x (Nil)))))
;         (let p-attr (Attributes (map-insert p-e "static" l1)))
;         (let l3 (+ l1 l2))
;         (let s-attr (Attributes (map-insert s-e "static" l3)))
;         (union
;             (Seq (Attributes s-e) (Cons compaction (Cons x xs)))
;             (Seq s-attr (Cons (Par p-attr (Cons new-S ys)) xs))
;         )
;     )
;     :ruleset control
; )
