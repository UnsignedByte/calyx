1c1,50
< component main() -> () {                                                                                                                                                                                 
---
> extern "/home/eys29/.calyx/primitives/memories/seq.sv" {
>   primitive seq_mem_d1[WIDTH, SIZE, IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
>   primitive seq_mem_d2[WIDTH, D0_SIZE, D1_SIZE, D0_IDX_SIZE, D1_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
>   primitive seq_mem_d3[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @data addr2: D2_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
>   primitive seq_mem_d4[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D3_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE, D3_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @data addr2: D2_IDX_SIZE, @write_together @data addr3: D3_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
> }
> extern "/home/eys29/.calyx/primitives/core.sv" {
>   comb primitive std_slice<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
>   comb primitive std_pad<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
>   comb primitive std_cat<"share"=1>[LEFT_WIDTH, RIGHT_WIDTH, OUT_WIDTH](@data left: LEFT_WIDTH, @data right: RIGHT_WIDTH) -> (out: OUT_WIDTH);
>   comb primitive std_bit_slice<"share"=1>[IN_WIDTH, START_IDX, END_IDX, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
>   comb primitive std_not<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH);
>   comb primitive std_and<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_or<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_xor<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_sub<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_gt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_lt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_eq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_neq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_ge<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_le<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
>   comb primitive std_lsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_rsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
>   comb primitive std_mux<"share"=1>[WIDTH](@data cond: 1, @data tru: WIDTH, @data fal: WIDTH) -> (out: WIDTH);
> }
> primitive undef<"share"=1>[WIDTH]() -> (out: WIDTH) {
>   assign out = 'x;
> }
> comb primitive std_const<"share"=1>[WIDTH, VALUE]() -> (out: WIDTH) {
>   assign out = VALUE;
> }
> comb primitive std_wire<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH) {
>   assign out = in;
> }
> comb primitive std_add<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH) {
>   assign out = left + right;
> }
> primitive std_reg<"state_share"=1>[WIDTH](@write_together @data in: WIDTH, @write_together @interval @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@stable out: WIDTH, @done done: 1) {
>   always_ff @(posedge clk) begin
>     if (reset) begin
>        out <= 0;
>        done <= 0;
>     end else if (write_en) begin
>       out <= in;
>       done <= 1'd1;
>     end else done <= 1'd0;
>   end
> }
> component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
3,16c52,64
<       //Modified to 64 width address because XRT expects 64 bit memory addresses
<       ref A0 = seq_mem_d1(32,8,3);
<       A_read0_0 = std_reg(32);
<       ref B0 = seq_mem_d1(32,8,3);
<       B_read0_0 = std_reg(32);
<       ref Sum0 = seq_mem_d1(32,8,3);
<       add0 = std_add(32);
<       add1 = std_add(4);
<       const0 = std_const(4,0);
<       const1 = std_const(4,7);
<       const2 = std_const(4,1);
<       i0 = std_reg(4);
<       le0 = std_le(4);
<       bit_slice = std_bit_slice(4,0,2,3);
---
>     ref A0 = seq_mem_d1(32, 8, 3);
>     A_read0_0 = std_reg(32);
>     ref B0 = seq_mem_d1(32, 8, 3);
>     B_read0_0 = std_reg(32);
>     ref Sum0 = seq_mem_d1(32, 8, 3);
>     add0 = std_add(32);
>     add1 = std_add(4);
>     const0 = std_const(4, 0);
>     const1 = std_const(4, 7);
>     const2 = std_const(4, 1);
>     i0 = std_reg(4);
>     le0 = std_le(4);
>     bit_slice = std_bit_slice(4, 0, 2, 3);
19,26d66
<     A0.write_en = 1'b0;
<     B0.write_en = 1'b0;
<     
<     bit_slice.in = i0.out;
<     comb group cond0 {
<       le0.left = i0.out;
<       le0.right = const1.out;
<     }
32d71
<     //modified upd0 and upd1 to use seq_mem correctly
36,37c75,76
<       A0.content_en = 1'b1;
<       A_read0_0.in = 1'd1 ? A0.read_data;
---
>       A0.content_en = 1'd1;
>       A_read0_0.in = A0.read_data;
40d78
<     //see comment for upd0
44,45c82,83
<       B0.content_en = 1'b1;
<       B_read0_0.in = 1'd1 ? B0.read_data;
---
>       B0.content_en = 1'd1;
>       B_read0_0.in = B0.read_data;
52c90
<       B0.content_en = 1'b1;
---
>       B0.content_en = 1'd1;
55c93
<       A0.content_en = 1'b1;
---
>       A0.content_en = 1'd1;
58c96
<       Sum0.write_data = 1'd1 ? add0.out;
---
>       Sum0.write_data = add0.out;
65c103
<       i0.in = 1'd1 ? add1.out;
---
>       i0.in = add1.out;
67a106,112
>     comb group cond0 {
>       le0.left = i0.out;
>       le0.right = const1.out;
>     }
>     A0.write_en = 1'd0;
>     B0.write_en = 1'd0;
>     bit_slice.in = i0.out;
81c126
<       }                                  
---
>       }
