extern "/home/eys29/.calyx/primitives/memories/seq.sv" {
  primitive seq_mem_d1[WIDTH, SIZE, IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
  primitive seq_mem_d2[WIDTH, D0_SIZE, D1_SIZE, D0_IDX_SIZE, D1_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
  primitive seq_mem_d3[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @data addr2: D2_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
  primitive seq_mem_d4[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D3_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE, D3_IDX_SIZE](@clk clk: 1, @reset reset: 1, @write_together @data addr0: D0_IDX_SIZE, @write_together @data addr1: D1_IDX_SIZE, @write_together @data addr2: D2_IDX_SIZE, @write_together @data addr3: D3_IDX_SIZE, @write_together @interval @go content_en: 1, @write_together(2) write_en: 1, @write_together(2) @data write_data: WIDTH) -> (@stable read_data: WIDTH, @done done: 1);
}
extern "/home/eys29/.calyx/primitives/core.sv" {
  comb primitive std_slice<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_pad<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_cat<"share"=1>[LEFT_WIDTH, RIGHT_WIDTH, OUT_WIDTH](@data left: LEFT_WIDTH, @data right: RIGHT_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_bit_slice<"share"=1>[IN_WIDTH, START_IDX, END_IDX, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_not<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH);
  comb primitive std_and<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_or<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_xor<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_sub<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_gt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_lt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_eq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_neq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_ge<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_le<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_lsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_rsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_mux<"share"=1>[WIDTH](@data cond: 1, @data tru: WIDTH, @data fal: WIDTH) -> (out: WIDTH);
}
primitive undef<"share"=1>[WIDTH]() -> (out: WIDTH) {
  assign out = 'x;
}
comb primitive std_const<"share"=1>[WIDTH, VALUE]() -> (out: WIDTH) {
  assign out = VALUE;
}
comb primitive std_wire<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH) {
  assign out = in;
}
comb primitive std_add<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH) {
  assign out = left + right;
}
primitive std_reg<"state_share"=1>[WIDTH](@write_together @data in: WIDTH, @write_together @interval @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@stable out: WIDTH, @done done: 1) {
  always_ff @(posedge clk) begin
    if (reset) begin
       out <= 0;
       done <= 0;
    end else if (write_en) begin
      out <= in;
      done <= 1'd1;
    end else done <= 1'd0;
  end
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    ref A0 = seq_mem_d1(32, 8, 3);
    A_read0_0 = std_reg(32);
    ref B0 = seq_mem_d1(32, 8, 3);
    B_read0_0 = std_reg(32);
    ref Sum0 = seq_mem_d1(32, 8, 3);
    add0 = std_add(32);
    add1 = std_add(4);
    const0 = std_const(4, 0);
    const1 = std_const(4, 7);
    const2 = std_const(4, 1);
    i0 = std_reg(4);
    le0 = std_le(4);
    bit_slice = std_bit_slice(4, 0, 2, 3);
  }
  wires {
    group let0<"static"=1> {
      i0.in = const0.out;
      i0.write_en = 1'd1;
      let0[done] = i0.done;
    }
    group upd0<"static"=2> {
      A_read0_0.write_en = A0.done;
      A0.addr0 = bit_slice.out;
      A0.content_en = 1'd1;
      A_read0_0.in = A0.read_data;
      upd0[done] = A_read0_0.done ? 1'd1;
    }
    group upd1<"static"=2> {
      B_read0_0.write_en = B0.done;
      B0.addr0 = bit_slice.out;
      B0.content_en = 1'd1;
      B_read0_0.in = B0.read_data;
      upd1[done] = B_read0_0.done ? 1'd1;
    }
    group upd2<"static"=1> {
      Sum0.addr0 = bit_slice.out;
      Sum0.content_en = 1'd1;
      Sum0.write_en = 1'd1;
      B0.content_en = 1'd1;
      B0.addr0 = bit_slice.out;
      A0.addr0 = bit_slice.out;
      A0.content_en = 1'd1;
      add0.left = B_read0_0.out;
      add0.right = A_read0_0.out;
      Sum0.write_data = add0.out;
      upd2[done] = Sum0.done ? 1'd1;
    }
    group upd3<"static"=1> {
      i0.write_en = 1'd1;
      add1.left = i0.out;
      add1.right = const2.out;
      i0.in = add1.out;
      upd3[done] = i0.done ? 1'd1;
    }
    comb group cond0 {
      le0.left = i0.out;
      le0.right = const1.out;
    }
    A0.write_en = 1'd0;
    B0.write_en = 1'd0;
    bit_slice.in = i0.out;
  }
  control {
    seq {
      let0;
      while le0.out with cond0 {
        seq {
          par {
            upd0;
            upd1;
          }
          upd2;
          upd3;
        }
      }
    }
  }
}
