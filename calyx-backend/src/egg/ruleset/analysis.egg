; -----------------------------------------------------------------------------
; DATATYPES
; -----------------------------------------------------------------------------

; Cell
(datatype _Cell)
(function Cell (String) _Cell)

; Set[Cell]
(sort CellSetBase (Set _Cell))
(sort _CellSet)
(function CellSet (CellSetBase) _CellSet)

; Group
(datatype _Group)
; TODO(cgyurgyik): Add static groups to guarantee the "static" attribute.
; TODO(cgyurgyik): Add combinational groups.
(function Group (String _CellSet) _Group)

; Attributes
(sort AttributeMap (Map String i64))
(datatype _Attributes)
(function Attributes (AttributeMap) _Attributes)

; List
(datatype Control)
(datatype List)
(function Cons (Control List) List)
(function Nil () List)

; Control
(function Enable (_Group _Attributes) Control)
(function Seq (_Attributes List) Control)
(function Par (_Attributes List) Control)

; Set[Control]
(sort ControlSetBase (Set Control))
(sort _ControlSet)
(function ControlSet (ControlSetBase) _ControlSet)

(ruleset analysis)

(function c-union (_ControlSet _ControlSet) _ControlSet)
(rule
    (
        (= a (ControlSet x))
        (= b (ControlSet y))
    )
    (
        (set (c-union a b) (ControlSet (set-union x y)))
    )
    :ruleset analysis
)

; (function c-length (_ControlSet) i64)
; (rule
;     (
;         (= C (ControlSet c))
;     )
;     (
;         (set (c-length C) (set-length c))
;     )
;     :ruleset analysis
; )

(function car (List) Control)
(rewrite
    (car (Cons x xs))
    x
)

(function cdr (List) List)
(rewrite
    (cdr (Cons x xs))
    xs
)
(rewrite
    (cdr (Nil))
    (Nil)
)

(function list-length (List) i64)

(set (list-length (Nil)) 0)

(rule
    ((Cons x xs)
        (= xs-length (list-length xs)))
    ((set (list-length (Cons x xs)) (+ xs-length 1)))
)

(function list-concat (List List) List)
(rewrite
    (list-concat (Cons x xs) (Nil))
    (Cons x xs)
    :ruleset analysis
)
(rewrite
    (list-concat (Nil) (Cons x xs))
    (Cons x xs)
    :ruleset analysis
)

(rewrite
    (list-concat (Cons x (Nil)) (Cons y ys))
    (Cons x (Cons y ys))
    :ruleset analysis
)

(rewrite
    (list-concat (Cons x xs) ys)
    (Cons x (list-concat xs ys))
)


(function list-reverse (List) List)
(rewrite
    (list-reverse (Nil))
    (Nil)
    :ruleset analysis
)
(rewrite
    (list-reverse (Cons x xs))
    (list-concat (list-reverse xs) (Cons x (Nil)))
    :ruleset analysis
)

(function _sliceB (List i64) List :unextractable) ; [begin, N)
(rewrite
    (_sliceB (Cons x xs) 0)
    (Cons x xs)
    :ruleset analysis
)
(rewrite
    (_sliceB (Cons x xs) begin)
    (_sliceB xs (- begin 1))
    :when ((> begin 0))
    :ruleset analysis
)

(function _sliceE (List i64) List :unextractable) ; [0, end)
(rewrite
    (_sliceE (Cons x xs) 0)
    (Nil)
    :ruleset analysis
)
(rewrite
    (_sliceE (Cons x xs) end)
    (Cons x (_sliceE xs (- end 1)))
    :when ((> end 0) (< end (list-length (Cons x xs))))
    :ruleset analysis
)
(rewrite
    (_sliceE (Cons x xs) end)
    (Cons x xs)
    :when ((= end (list-length (Cons x xs))))
    :ruleset analysis
)

(function list-slice (List i64 i64) List) ; [begin, end)
(rewrite
    (list-slice (Cons x xs) begin end)
    (_sliceE (_sliceB (Cons x xs) begin) (- end begin))
    :when ((>= end begin))
    :ruleset analysis
)

(rewrite
    (list-length (list-slice xs a b))
    (- b a)
    :when ((>= b a))
    :ruleset analysis
)

; (list-find x xs) 
; Returns the sub-list with x as the head, or nil if x is not found in xs.
(function list-find (Control List) List)
(rewrite
    (list-find y (Cons x xs))
    (Cons x xs)
    :when ((= x y))
    :ruleset analysis
)
(rewrite
    (list-find y (Cons x xs))
    (list-find y xs)
    :when ((!= x y))
    :ruleset analysis
)
(rewrite
    (list-find y (Nil))
    (Nil)
    :ruleset analysis
)

; -----------------------------------------------------------------------------
; ANALYSIS
; -----------------------------------------------------------------------------

; TODO(cgyurgyik): also need to account for memory-ordering.
(function exclusive (Control Control) bool :unextractable)

(rule
    (
        (= A (Enable (Group n1 (CellSet s1)) a1))
        (= B (Enable (Group n2 (CellSet s2)) a2))
        (> (set-length (set-intersect s1 s2)) 0)
    )
    (
        (set (exclusive A B) false)
    )
    :ruleset analysis
)

(rule
    (
        (= A (Enable (Group n1 (CellSet s1)) (Attributes m1)))
        (= B (Enable (Group n2 (CellSet s2)) (Attributes m2)))
        (= (set-length (set-intersect s1 s2)) 0)
    )
    (
        (set (exclusive A B) true)
    )
    :ruleset analysis
)

; Returns whether Control is exclusive with all values in List.
(function exclusive-with-all (Control List) bool)
(rule
    (
        (= E (Enable g a))
    )
    (
        (set (exclusive-with-all (Enable g a) (Nil)) true)
    )
    :ruleset analysis
)

(rule
    (
        (= E (Enable g a))
        (= _ (Cons x xs))
        (= result (exclusive E x))
        (= xs-exclusive (exclusive-with-all E xs))

    )
    (
        (set (exclusive-with-all E (Cons x xs)) (and result xs-exclusive))
    )
    :ruleset analysis
)

(rule
    (
        (= E (Enable g a))
        (= _ (Cons (Seq a ys) xs))
        (= ys-exclusive (exclusive-with-all E ys))
        (= xs-exclusive (exclusive-with-all E xs))
    )
    (
        (set (exclusive-with-all E (Cons (Seq a ys) xs)) (and ys-exclusive xs-exclusive))
    )
    :ruleset analysis
)

(rewrite
    (exclusive-with-all (Enable g _) (Cons (Par a ys) xs))
    (and (exclusive-with-all (Enable g _) ys) (exclusive-with-all (Enable g _) xs))
    :ruleset analysis
)

(function max-latency (List) i64 :merge (min old new))
(set (max-latency (Nil)) 0)

(rule ; (max-latency Enable)
    (
        (= E (Cons (Enable _ (Attributes m)) xs))
        (= incumbent (max-latency xs))
        (map-contains m "promotable")
        (= current (map-get m "promotable"))
    )
    (
        (set (max-latency E) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency @static(N) Seq)
    (
        (= E (Cons (Seq (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-contains m "static")
        (= current (map-get m "static"))
    )
    (
        (set (max-latency (Cons (Seq (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency Seq) - No "static" attribute; go through children.
    (
        (= E (Cons (Seq (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-not-contains m "static")
        (= current (max-latency ys))
    )
    (
        (set (max-latency (Cons (Seq (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency @static(N) Par)
    (
        (= E (Cons (Par (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-contains m "static")
        (= current (map-get m "static"))
    )
    (
        (set (max-latency (Cons (Par (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)

(rule ; (max-latency Par) - No "static" attribute; go through children.
    (
        (= E (Cons (Par (Attributes m) ys) xs))
        (= incumbent (max-latency xs))
        (map-not-contains m "static")
        (= current (max-latency ys))
    )
    (
        (set (max-latency (Cons (Par (Attributes m) ys) xs)) (max current incumbent))
    )
    :ruleset analysis
)


(function sum-latency (List) i64 :merge (min old new))
(set (sum-latency (Nil)) 0)

(rule ; (sum-latency Enable)
    (
        (= ys (Cons (Enable _ (Attributes m)) xs))
        (= sum (sum-latency xs))
        (map-contains m "promotable")
        (= latency (map-get m "promotable"))
    )
    (
        (set (sum-latency ys) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency @static(N) Seq)
    (
        (= xss (Cons (Seq (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-contains m "static")
        (= latency (map-get m "static"))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency Seq) - No "static" attribute; Go through children.
    (
        (= xss (Cons (Seq (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-not-contains m "static")
        (= latency (sum-latency ys))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency @static(N) Par)
    (
        (= xss (Cons (Par (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-contains m "static")
        (= latency (map-get m "static"))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)

(rule ; (sum-latency Par)
    (
        (= xss (Cons (Par (Attributes m) ys) xs))
        (= sum (sum-latency xs))
        (map-not-contains m "static")
        (= latency (max-latency ys))
    )
    (
        (set (sum-latency xss) (+ sum latency))
    )
    :ruleset analysis
)
